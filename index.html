<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Shooter + Building (Browser Prototype)</title>
<style>
  body { margin:0; overflow:hidden; background:#111; color:#fff; font-family:sans-serif; }
  #hud {
    position: absolute; left: 12px; top: 12px; z-index: 10;
    background: rgba(0,0,0,0.4); padding:8px 12px; border-radius:8px;
  }
  #hint { position:absolute; left:50%; transform:translateX(-50%); bottom:12px; background:rgba(0,0,0,0.4); padding:6px 10px; border-radius:6px;}
  canvas { display:block; }
  #crosshair {
    position: absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:10px;height:10px; pointer-events:none; z-index:9;
  }
  #crosshair:after{
    content:""; position:absolute; left:50%; top:50%; width:2px; height:20px; background:#fff; transform:translate(-50%,-50%);
  }
  #crosshair:before{
    content:""; position:absolute; left:50%; top:50%; width:20px; height:2px; background:#fff; transform:translate(-50%,-50%);
  }
</style>
</head>
<body>
<div id="hud">
  <div>Health: <span id="health">100</span></div>
  <div>Ammo: <span id="ammo">30</span> / <span id="mag">30</span></div>
  <div>Blocks: <span id="blocks">20</span></div>
  <div>Enemies: <span id="enemies">0</span></div>
</div>
<div id="hint">Click to play • Left-click shoot • E place block • Q remove block • R reload</div>
<div id="crosshair"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/PointerLockControls.js"></script>

<script>
/* ----- Basic scene + player ----- */
let scene, camera, renderer, controls;
let clock = new THREE.Clock();
let player = { health:100, ammo:30, mag:30, blocks:20 };
let enemies = [];
const enemyGroup = new THREE.Group();

init();
animate();

function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb); // sky-like

  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0,1.6,5);

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  // light
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
  hemi.position.set(0, 50, 0);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(-10, 20, 10);
  scene.add(dir);

  // ground
  const groundMat = new THREE.MeshStandardMaterial({ color:0x2b6d2b });
  const ground = new THREE.Mesh(new THREE.BoxGeometry(200,1,200), groundMat);
  ground.position.y = -0.5;
  scene.add(ground);

  // some visual landmarks/platforms
  const boxMat = new THREE.MeshStandardMaterial({ color:0x8b5a2b });
  for(let i=0;i<6;i++){
    const b = new THREE.Mesh(new THREE.BoxGeometry(8,1,8), boxMat);
    b.position.set(i* -12 + 20, i%2 ? 0.5 : 3, (i%3)-1 * 6);
    scene.add(b);
  }

  // enemy container
  scene.add(enemyGroup);

  // controls
  controls = new THREE.PointerLockControls(camera, document.body);
  document.addEventListener('click', () => { controls.lock(); }, { once:true });

  // movement state
  window.inputState = { forward:false, back:false, left:false, right:false, jump:false };
  document.addEventListener('keydown', (e) => {
    if(e.code==='KeyW') inputState.forward=true;
    if(e.code==='KeyS') inputState.back=true;
    if(e.code==='KeyA') inputState.left=true;
    if(e.code==='KeyD') inputState.right=true;
    if(e.code==='Space') inputState.jump=true;
    if(e.code==='KeyR') reload();
    if(e.code==='KeyE') placeBlock();
    if(e.code==='KeyQ') removeBlock();
  });
  document.addEventListener('keyup', (e) => {
    if(e.code==='KeyW') inputState.forward=false;
    if(e.code==='KeyS') inputState.back=false;
    if(e.code==='KeyA') inputState.left=false;
    if(e.code==='KeyD') inputState.right=false;
    if(e.code==='Space') inputState.jump=false;
  });

  // mouse shoot
  document.addEventListener('mousedown', (e) => {
    if(e.button === 0) shoot();
  });

  // resize
  window.addEventListener('resize', ()=> {
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // spawn a few enemies
  for(let i=0;i<4;i++) spawnEnemy(new THREE.Vector3(-20 + i*12, 0.5, -30 - (i%2)*8));

  // update HUD initially
  updateHUD();
}

/* ----- HUD ----- */
function updateHUD(){
  document.getElementById('health').innerText = Math.max(0, Math.floor(player.health));
  document.getElementById('ammo').innerText = player.ammo;
  document.getElementById('mag').innerText = player.mag;
  document.getElementById('blocks').innerText = player.blocks;
  document.getElementById('enemies').innerText = enemies.length;
}

/* ----- Movement + physics (very basic) ----- */
let velocity = new THREE.Vector3(0,0,0);
let canJump = true;

function handleMovement(delta){
  const speed = 6; // units per second
  let dir = new THREE.Vector3();
  controls.getDirection(dir); // forward vector
  // forward vector points -z in camera space; use its x,z components
  let forward = new THREE.Vector3(dir.x, 0, dir.z).normalize();
  let right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

  let move = new THREE.Vector3();
  if(inputState.forward) move.add(forward);
  if(inputState.back) move.sub(forward);
  if(inputState.left) move.sub(right);
  if(inputState.right) move.add(right);
  move.normalize();

  // apply movement
  velocity.x += move.x * speed * delta;
  velocity.z += move.z * speed * delta;

  // gravity
  velocity.y -= 20 * delta; // gravity strength

  // jump
  if(inputState.jump && canJump){
    velocity.y = 8;
    canJump = false;
  }

  // integrate
  controls.moveRight(-velocity.x * delta);
  controls.moveForward(-velocity.z * delta);
  camera.position.y += velocity.y * delta;

  // ground collision
  if(camera.position.y < 1.6){
    camera.position.y = 1.6;
    velocity.y = 0;
    canJump = true;
  }

  // damping
  velocity.x -= velocity.x * 10 * delta;
  velocity.z -= velocity.z * 10 * delta;
}

/* ----- Shooting (raycast) ----- */
const bulletRange = 200;
const damage = 34;
let lastShotAt = 0;
const fireRate = 0.15; // seconds

function shoot(){
  const now = performance.now()/1000;
  if(now - lastShotAt < fireRate) return;
  if(player.mag <= 0){
    // no bullets in magazine
    return;
  }
  lastShotAt = now;
  player.mag--;
  updateHUD();

  // raycast from camera center
  const origin = camera.position.clone();
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  const ray = new THREE.Raycaster(origin, dir, 0, bulletRange);
  const hit = ray.intersectObjects(enemyGroup.children.concat(scene.children), true);

  if(hit.length > 0){
    for(let h of hit){
      if(h.object.userData.isEnemy){
        h.object.userData.hp -= damage;
        spawnHitEffect(h.point);
        if(h.object.userData.hp <= 0) killEnemy(h.object.userData.id);
        break;
      } else if(h.object.userData.isBlock){
        // hitting player's placed block removes it (single hit)
        scene.remove(h.object);
      } else {
        spawnHitEffect(h.point);
        break;
      }
    }
  } else {
    // spawn small tracer forward
    const missPoint = origin.clone().add(dir.multiplyScalar(20));
    spawnHitEffect(missPoint);
  }
}

/* ----- Reload ----- */
function reload(){
  const reserve = player.ammo;
  const toLoad = Math.min(30 - player.mag, reserve);
  if(toLoad <= 0) return;
  player.mag += toLoad;
  player.ammo -= toLoad;
  updateHUD();
}

/* ----- Building: place block in front of camera ----- */
function placeBlock(){
  if(player.blocks <= 0) return;
  // use raycast forward to place block snapped to grid in front
  const origin = camera.position.clone();
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  const point = origin.clone().add(dir.multiplyScalar(4)); // 4 units ahead
  const gridPos = new THREE.Vector3(
    Math.round(point.x),
    Math.round(point.y - 0.5),
    Math.round(point.z)
  );
  const b = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0xcccccc}));
  b.position.copy(gridPos).add(new THREE.Vector3(0,0.5,0));
  b.userData.isBlock = true;
  scene.add(b);
  player.blocks--;
  updateHUD();
}

/* ----- Remove block under crosshair ----- */
function removeBlock(){
  const origin = camera.position.clone();
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  const ray = new THREE.Raycaster(origin, dir, 0, 6);
  const hits = ray.intersectObjects(scene.children, true);
  if(hits.length>0){
    const target = hits[0].object;
    if(target.userData.isBlock){
      scene.remove(target);
      player.blocks++;
      updateHUD();
    }
  }
}

/* ----- Enemies: simple AI (wander towards player) ----- */
let enemyIdCounter = 1;
function spawnEnemy(pos){
  const geom = new THREE.BoxGeometry(1,2,1);
  const mat = new THREE.MeshStandardMaterial({ color:0x880000 });
  const mesh = new THREE.Mesh(geom, mat);
  mesh.position.copy(pos);
  mesh.userData = { isEnemy:true, hp:100, id: enemyIdCounter++ };
  enemyGroup.add(mesh);
  enemies.push(mesh.userData);
  updateHUD();
}

function killEnemy(id){
  const idx = enemyGroup.children.findIndex(m => m.userData.id === id);
  if(idx >= 0){
    const m = enemyGroup.children[idx];
    // simple death effect
    const puff = new THREE.Mesh(new THREE.SphereGeometry(0.2,8,8), new THREE.MeshStandardMaterial({color:0xffaaaa}));
    puff.position.copy(m.position);
    scene.add(puff);
    setTimeout(()=> scene.remove(puff), 400);
    enemyGroup.remove(m);
    const eidx = enemies.findIndex(en => en.id === id);
    if(eidx>=0) enemies.splice(eidx,1);
    updateHUD();
  }
}

/* ----- Enemy behavior each frame ----- */
function updateEnemies(delta){
  enemyGroup.children.forEach((m)=>{
    const toPlayer = new THREE.Vector3().subVectors(camera.position, m.position);
    toPlayer.y = 0;
    const dist = toPlayer.length();
    if(dist > 1){
      const dir = toPlayer.normalize();
      m.position.add(dir.multiplyScalar(1.5 * delta)); // enemy speed
    } else {
      // attack player
      player.health -= 10 * delta;
      if(player.health <= 0) {
        player.health = 0;
        // respawn player
        camera.position.set(0,1.6,5); velocity.set(0,0,0);
        player.health = 100; player.mag = 30; player.ammo = 90; player.blocks = 20;
      }
      updateHUD();
    }
    // simple random wandering when far
    if(dist > 25){
      m.position.x += Math.sin((performance.now()+m.position.x)*0.001) * 0.5 * delta;
      m.position.z += Math.cos((performance.now()+m.position.z)*0.001) * 0.5 * delta;
    }
  });
}

/* ----- small hit visual effect ----- */
function spawnHitEffect(pos){
  const s = new THREE.Mesh(new THREE.SphereGeometry(0.08,6,6), new THREE.MeshStandardMaterial({color:0xffff66, emissive:0xffaa33}));
  s.position.copy(pos);
  scene.add(s);
  setTimeout(()=> scene.remove(s), 200);
}

/* ----- main loop ----- */
function animate(){
  const delta = Math.min(0.05, clock.getDelta());
  handleMovement(delta);
  updateEnemies(delta);
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

/* ----- utility: small velocity vector on global scope ----- */
let velocity = new THREE.Vector3(0,0,0);

/* ----- initialize ammo reserves (extra ammo) ----- */
player.ammo = 90; // reserve ammo
player.mag = 30;

/* ----- spawn more enemies on key press (for testing) ----- */
document.addEventListener('keydown', (e)=>{
  if(e.code === 'KeyP'){ // spawn one enemy in front
    const d = new THREE.Vector3(); camera.getWorldDirection(d);
    const spawnPos = camera.position.clone().add(d.multiplyScalar(20));
    spawnPos.y = 0.5;
    spawnEnemy(spawnPos);
  }
});

/* ----- small help: show enemy count on spawn change ----- */
updateHUD();

</script>
</body>
</html>
